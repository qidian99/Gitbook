# MYSQL

## MVCC底层

MVCC：高并发，需要实现事务内存

利用大量undo和回滚日志

### MySQL：事务id必须通过更新操作来完成

* Begin以后改东西了，插一条新纪录，附带着事务ID，历史数据通过指针指向undo日志
* 在第一select语句的生成一次性的视图readView，包含查询时所有**未提交**的事务id**数组**（最小的是min\_id）和**已创建的**最大事务id（max\_id）组成。
  * 注意max\_id可以是已提交事务
* 版本链比对（从最新的开始，通过undo日志反向遍历）
  * 如果transaction id落在已提交事务范围，表示这个版本是由已提交的事务生成的，**可见**
  * 如果落在未开始事务，表示这个版本是由将来启动的事务生成的，不可见
  * 如果落在min\_id和max\_id中间，两种情况
    * 如果该记录（row）的transaction\_id在数组中，说明这个版本是由还没提交的事务生成的，不可见。**但是如果是当前自己的事务（session），则可见**
    * 如果的transaction\_id不在数组中，表示着版本是已经提交了的事务生成的，可见
* 删除操作
  * Update的特殊情况
  * 复制版本链上**最新**的数据
  * 将transaction\_id修改成删除操作的的transaction\_id
  * 在该记录头部信息的delete\_flag标记位置写上true，表示当前记录已经被删除
  * 查询规则不变，查到该记录的时候如果标记是true，则不返回

## Index: 方便查询的排好序的数据结构

* binary tree
* Red black tree: balanced binary tree 平衡二叉数
* B-tree \(mulitree 多叉平衡树）
* B+ tree

![](../../.gitbook/assets/0%20%281%29.png)

如图所示，区别有以下两点：

1. B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。

2. B+树中所有叶子节点都是通过指针连接在一起，而B树不会。

B+树的优点：

1. 非叶子节点不会带上ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。

2. 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。

B树的优点：

对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。

b+tree的中间索引在RAM，IO更快

## 索引实现（跟表相关的，不是数据库！）

### MyISAM：

* MYI： index 找到data rowID（mySQL帮你建的隐藏数列）/索引
* MYD： data，通过.myi的索引查询获得数据
* frm：schema
* 非聚集索引

### InnoDB：

* B+ tree
* 聚集索引，叶子节点包含了完整的记录
* InnoDB索引实现必须建主键
* B+数如果MySQL没有找到唯一列，它会帮着维护rowID（mySQL帮你建的隐藏数列）/索引
* 非主键索引结构叶子结点存储的是主键值，**保证一致性**和**节省存储空间**

\*\*\*\*

传统数据库存储采用的都是B tree，这是由于其在查询和顺序插入时有利于减少寻道次数的组织形式。我们知道磁盘寻道时间是非常慢的，一般在10ms左右。磁盘的随机读写慢就慢在寻道上面。对于随机写入B tree会消耗大量的时间在磁盘寻道上，导致速度很慢。我们知道SSD具有更快的寻道时间，但并没有从根本上解决这个问题。 对于90%以上场景都是写入的时序数据库，B tree很明显是不合适的。 业界主流都是采用LSM tree替换B tree，比如Hbase, Cassandra等nosql中。这里我们详细介绍一下。 LSM tree包括内存里的数据结构和磁盘上的文件两部分。分别对应Hbase里的MemStore和HLog;对应Cassandra里的MemTable和sstable。 LSM tree操作流程如下： 1. 数据写入和更新时首先写入位于内存里的数据结构。为了避免数据丢失也会先写到WAL文件中。 2. 内存里的数据结构会定时或者达到固定大小会刷到磁盘。这些磁盘上的文件不会被修改。 3. 随着磁盘上积累的文件越来越多，会定时的进行合并操作，消除冗余数据，减少文件数量。

